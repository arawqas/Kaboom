local OrionLib = loadstring(game:HttpGet(('https://raw.githubusercontent.com/luke1for1/zenith/main/orionMobile')))()
local tweenService = game:GetService("TweenService")

-- anti afk

local virtualUser = game:GetService("VirtualUser")

game:GetService("Players").LocalPlayer.Idled:Connect(function()
    virtualUser:CaptureController()
    virtualUser:ClickButton2(Vector2.new())
end)

local TeleportService = game:GetService("TeleportService")


local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local HttpService = game:GetService("HttpService")

local username = Players.LocalPlayer.Name
local userId = Players.LocalPlayer.UserId


local highlights = {}
local espChamColor = Color3.fromRGB(255, 0, 0)
local espOutlineColor = Color3.fromRGB(255, 0, 0)
local esp = false
local doubloons = false
local totemESP = false

local Window = OrionLib:MakeWindow({
    Name = "Zenith | V1",
    HidePremium = false,
    SaveConfig = true,
    ConfigFolder = "zv12"
})

OrionLib:MakeNotification({
    Name = "Zenith Productions!",
    Content = "Successfully executed Zenith v1",
    Image = nil,
    Time = 5
})


--[[


$$$$$$$$\  $$$$$$\  $$$$$$$\   $$$$$$\  
\__$$  __|$$  __$$\ $$  __$$\ $$  __$$\ 
$$ |   $$ /  $$ |$$ |  $$ |$$ /  \__|
$$ |   $$$$$$$$ |$$$$$$$\ |\$$$$$$\  
$$ |   $$  __$$ |$$  __$$\  \____$$\ 
$$ |   $$ |  $$ |$$ |  $$ |$$\   $$ |
$$ |   $$ |  $$ |$$$$$$$  |\$$$$$$  |
\__|   \__|  \__|\_______/  \______/ 
                                        
                                                                        
--]]

local Farming = Window:MakeTab({
    Name = "Farming",
    Icon = nil,
    PremiumOnly = false
})

local Player = Window:MakeTab({
    Name = "Player",
    Icon = nil,
    PremiumOnly = false
})

local Misc = Window:MakeTab({
    Name = "Miscellaneous",
    Icon = nil,
    PremiumOnly = false
})

local Teleports = Window:MakeTab({
    Name = "Teleports",
    Icon = nil,
    PremiumOnly = false
})

--[[


$$\    $$\  $$$$$$\  $$$$$$$\  $$$$$$\  $$$$$$\  $$$$$$$\  $$\       $$$$$$$$\  $$$$$$\  
$$ |   $$ |$$  __$$\ $$  __$$\ \_$$  _|$$  __$$\ $$  __$$\ $$ |      $$  _____|$$  __$$\ 
$$ |   $$ |$$ /  $$ |$$ |  $$ |  $$ |  $$ /  $$ |$$ |  $$ |$$ |      $$ |      $$ /  \__|
\$$\  $$  |$$$$$$$$ |$$$$$$$  |  $$ |  $$$$$$$$ |$$$$$$$\ |$$ |      $$$$$\    \$$$$$$\  
\$$\$$  / $$  __$$ |$$  __$$<   $$ |  $$  __$$ |$$  __$$\ $$ |      $$  __|    \____$$\ 
\$$$  /  $$ |  $$ |$$ |  $$ |  $$ |  $$ |  $$ |$$ |  $$ |$$ |      $$ |      $$\   $$ |
\$  /   $$ |  $$ |$$ |  $$ |$$$$$$\ $$ |  $$ |$$$$$$$  |$$$$$$$$\ $$$$$$$$\ \$$$$$$  |
    \_/    \__|  \__|\__|  \__|\______|\__|  \__|\_______/ \________|\________| \______/ 
                                                                                        
                                                                                                                                                                        
--]]

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local TweenService = game:GetService("TweenService")
local RunService = game:GetService("RunService")
local LocalPlayer = Players.LocalPlayer
local char
local autoPickupGodSets = false

local function getPlayerCharacter()
    if LocalPlayer.Character then
        return LocalPlayer.Character
    end

    local character
    LocalPlayer.CharacterAdded:Wait()
    character = LocalPlayer.Character

    return character
end

local Packets = require(ReplicatedStorage.Modules.Packets)
local ItemData = require(ReplicatedStorage.Modules.ItemData)
local ItemIDS = require(ReplicatedStorage.Modules.ItemIDS)
local GameUtil = require(ReplicatedStorage.Modules.GameUtil)

local wwenabled = false
local wwspeed = 16
local autoPickupGold = false
local autoPickupCrystal = false

local wasteLeavesTo = 25
local autoleaves = false

local FarmingTweenSpeed = 10
local AutoTeleportDistance = 500
local autoHarvestRange = 100

local autopickupcoins = false
local autoPickupItems_Enabled = false

local onlyIce = false

local AutoPlant_Enabled = false
local AutoTeleport_Enabled = false
local AutoHarvest_Enabled = false
local onlyBushes = false
local autoGetChest = false

local SelectedFruits = {}
local PlayerFruits = {}

local autohit_players = false
local autohit_resources = false
local autohit_buildings = false
local autohit_critters = false

local SelectedFruit = nil
local wasteFruit = false
local wasteFruitTo = 10

local webhookSending = false
local fruitToSend = nil
local webhookUrl1 = nil
local webhookInterval = 10
local webhookInSeconds = (webhookInterval * 60)
local nodeAura = false

local autoheal_enabled = false
local autohealTo = 100
local autohealAt = 98
local autohealFruit = nil
local autoHealCPS = 50

local webhookSending = false
local webhookUrl1 = ""
local webhookInterval = 10
local webhookInSeconds = 600
local fruitToSend = ""
local lastFruitValue = 0
local startFruitValue = 0

local autoPickup = false

local tps = {}
local tpenabled = false
local tptweenspeed = 12

local showPoints = false

local transportGold = false

local isGoldFarm = false

local BlacklistedItemsForFruits = {
    "Reinforced Chest",
    "Nest",
    "Fish Trap",
    "Chest",
    "Barley"
}

local goldFarm_Enabled = false
local autoCampfire_Enabled = false
local autoCoinPress_Enabled = false
local autoSmelt_Enabled = false
local autoPickupGold_Enabled = false


local tpinverval = 10

--[[


$$$$$$$$\ $$\   $$\ $$\   $$\  $$$$$$\ $$$$$$$$\ $$$$$$\  $$$$$$\  $$\   $$\  $$$$$$\  
$$  _____|$$ |  $$ |$$$\  $$ |$$  __$$\\__$$  __|\_$$  _|$$  __$$\ $$$\  $$ |$$  __$$\ 
$$ |      $$ |  $$ |$$$$\ $$ |$$ /  \__|  $$ |     $$ |  $$ /  $$ |$$$$\ $$ |$$ /  \__|
$$$$$\    $$ |  $$ |$$ $$\$$ |$$ |        $$ |     $$ |  $$ |  $$ |$$ $$\$$ |\$$$$$$\  
$$  __|   $$ |  $$ |$$ \$$$$ |$$ |        $$ |     $$ |  $$ |  $$ |$$ \$$$$ | \____$$\ 
$$ |      $$ |  $$ |$$ |\$$$ |$$ |  $$\   $$ |     $$ |  $$ |  $$ |$$ |\$$$ |$$\   $$ |
$$ |      \$$$$$$  |$$ | \$$ |\$$$$$$  |  $$ |   $$$$$$\  $$$$$$  |$$ | \$$ |\$$$$$$  |
\__|       \______/ \__|  \__| \______/   \__|   \______| \______/ \__|  \__| \______/ 
                                                                                    
                                                                                    
                                                                                    
--]]

local list = game:GetService("Players").LocalPlayer.PlayerGui.MainGui.RightPanel.Inventory.List

local function getValue(item)
    local list = game:GetService("Players").LocalPlayer.PlayerGui.MainGui.RightPanel.Inventory.List
    for i, v in next, list:GetChildren() do
        if v.Name == item and v:FindFirstChild("QuantityImage") and v.QuantityImage:FindFirstChild("QuantityText") then
            local value = tonumber(v.QuantityImage.QuantityText.Text)
            return value
        end
    end
    return nil
end

local function sendWebhook()
    if webhookUrl1 and fruitToSend then
        local fruitValue = getValue(fruitToSend)
        if fruitValue then
            local difference = fruitValue - lastFruitValue
            if lastFruitValue == 0 then
                startFruitValue = fruitValue
                difference = 0
            end
            lastFruitValue = fruitValue

            local data = {
                ["embeds"] = {{
                    ["title"] = "Fruit Value Update",
                    ["description"] = string.format("You have **%d** **%ss**.", fruitValue, fruitToSend),
                    ["color"] = 3426654, 
                    ["fields"] = {
                        {
                            ["name"] = "Starting Amount",
                            ["value"] = tostring(startFruitValue),
                            ["inline"] = true
                        },
                        {
                            ["name"] = "Current Amount",
                            ["value"] = tostring(fruitValue),
                            ["inline"] = true
                        },
                        {
                            ["name"] = "Amount made in the last " .. webhookInterval .. " minutes:",
                            ["value"] = tostring(difference),
                            ["inline"] = true
                        }
                    },
                    ["footer"] = {
                        ["text"] = "Zenith Productions",
                        ["icon_url"] = ""  
                    },
                    ["timestamp"] = os.date("!%Y-%m-%dT%H:%M:%SZ")
                }}
            }

            local response = request({
                Url = webhookUrl1,
                Method = "POST",
                Headers = {
                    ["Content-Type"] = "application/json"
                },
                Body = HttpService:JSONEncode(data)
            })

            if response.StatusCode ~= 200 then
                print("Webhook failed with status code: " .. response.StatusCode)
            end
        end
    end
end

local function startWebhookSending()
    spawn(function()
        while webhookSending do
            sendWebhook()
            wait(webhookInSeconds)
        end
    end)
end

local teamColors = {}

for _, team in ipairs(game:GetService("Teams"):GetChildren()) do
    table.insert(teamColors, team.TeamColor.Name)
end

local selectedTeamColor

local function testWebhook()
    if webhookUrl1 then
        local data = {
            ["embeds"] = {{
                ["title"] = "Test Webhook",
                ["description"] = "This is a test notification from Zenith.",
                ["color"] = 3426654, 
                ["fields"] = {
                    {
                        ["name"] = "Fruit",
                        ["value"] = "Fruit Name",
                        ["inline"] = true
                    },
                    {
                        ["name"] = "Value",
                        ["value"] = "Fruit Value",
                        ["inline"] = true
                    }
                },
                ["footer"] = {
                    ["text"] = "Zenith Productions",
                    ["icon_url"] = ""  
                },
                ["timestamp"] = os.date("!%Y-%m-%dT%H:%M:%SZ")
            }}
        }

        local response = request({
            Url = webhookUrl1,
            Method = "POST",
            Headers = {
                ["Content-Type"] = "application/json"
            },
            Body = HttpService:JSONEncode(data)
        })

        if response.StatusCode ~= 200 then
            print("Test webhook failed with status code: " .. response.StatusCode)
        else
            print("Test webhook sent successfully.")
        end
    end
end

local mt = getrawmetatable(game)
local oldIndex = mt.__index
setreadonly(mt, false)

mt.__index = function(t, k)
    if t:IsA("Humanoid") and k == "WalkSpeed" and wwenabled then
        return wwspeed
    end
    return oldIndex(t, k)
end

setreadonly(mt, true)

for Name, Data in next, ItemData do
    if Data.growthTime ~= nil and not table.find(BlacklistedItemsForFruits, Name) then
        table.insert(PlayerFruits, Name)
    end
end

table.sort(PlayerFruits, function(a, b)
    return ItemData[a].nourishment.health > ItemData[b].nourishment.health
end)

local params = RaycastParams.new()
params.FilterType = Enum.RaycastFilterType.Exclude
params.FilterDescendantsInstances = {LocalPlayer.Character}

local isrunning = false
local attackLoop

local allowedFruits = {}

for x, v in next, ItemData do
    if v.grows then
        table.insert(allowedFruits, x)
    end
end

local function PickUpChest(item)
    local eid = item:GetAttribute("EntityID")
    Packets.Pickup.send(eid)
end

local function GetIndex(name)
    for i,v in pairs(GameUtil.Data.inventory) do
        if v.name == name then
            return i
        end
    end
end

local function getHumanoidRootPart()
    local character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
    return character:WaitForChild("HumanoidRootPart")
end

local function teamcheck(player)
    return (LocalPlayer.Neutral or LocalPlayer.Team.Name == "NoTribe" or LocalPlayer.Team ~= player.Team)
end

local function PickUpItem(item)
    local eid = item:GetAttribute("EntityID")
    if eid then
        Packets.Pickup.send(eid)
    end
end

local function getClosestChest()
    local characterPosition = LocalPlayer.Character:GetPivot().Position
    local Parts = workspace:GetPartBoundsInRadius(characterPosition, 50)
    local nearestChest = nil
    local shortestDistance = math.huge

    for _, Part in ipairs(Parts) do
        if Part.Parent and Part.Parent:IsA("Model") and Part.Parent.Name == "Chest" then
            local distance = (Part.Position - characterPosition).Magnitude
            if distance < shortestDistance then
                shortestDistance = distance
                nearestChest = Part.Parent
            end
        end
    end

    if autoGetChest then
        if nearestChest then
        for i, v in ipairs(nearestChest:WaitForChild("Contents"):GetChildren()) do
            if v.Name == "Gold" then
                PickUpChest(v)
            end
        end
    end
    end

    return nearestChest
end


local allowedBushNames = {
    "Berry Bush",
    "Cloudberry Bush",
    "Bloodfruit Bush",
    "Sunfruit Bush",
    "Apple Tree",
    "Orange Tree",
    "Lemon Tree",
    "Banana Tree",
    "Sunfruit Bush",
    "Strawberry Bush",
    "Pear Cacti",
    "Carrot Plant Crop",
    "Bluefruit Bush",
    "Jelly Crop",
    "Oddberry Tree",
    "Strangefruit Tree",
    "Pumpkin Patch Crop"
}

function startAutoHit()
    if isrunning then return end
    isrunning = true
    attackLoop = coroutine.create(function()
        while isrunning do
            RunService.PostSimulation:Wait()
            if not autohit_enabled then
                break
            end
            local root = getHumanoidRootPart()
            if not root then
                continue
            end

            local attackparts = autoHit(root, autohit_range)
            for i, part in ipairs(attackparts) do

            end

            if #attackparts > 0 then
                hit(attackparts)
            else

            end
        end
    end)

    coroutine.resume(attackLoop)
end

function stopAutoHit()
    isrunning = false
    if attackLoop then
        coroutine.close(attackLoop)
        attackLoop = nil
    end
end

local function HasFruit(Box)
    return Box:FindFirstChild("Seed")
end

local function GetClosestBox()
    local characterPosition = LocalPlayer.Character:GetPivot().Position
    local Deployables = workspace:FindFirstChild("Deployables")
    if not Deployables then return nil end

    local Parts = Deployables:GetChildren()
    local Boxes = {}

    for _, Part in next, Parts do
        if Part.Name == "Plant Box" then
            local found = HasFruit(Part)
            
            if not found then
                local entityID = Part.Parent:GetAttribute("EntityID")
                if entityID then
                    table.insert(Boxes, {part = Part, entityID = entityID})
                else
                    table.insert(Boxes, Part)
                end
            end
        end
    end

    local Closest, LastDist = nil, math.huge

    for _, Box in next, Boxes do
        local Dist = (characterPosition - Box.Part:GetPivot().Position).Magnitude
        if Dist < LastDist then
            Closest = Box
            LastDist = Dist
        end
    end

    return Closest
end

local last_cast = 0
local AutoTeleportDistance = 150
local minDistance = 10

local function GetClosestBush()
    local characterPosition = LocalPlayer.Character:GetPivot().Position
    local Parts = workspace:GetPartBoundsInRadius(characterPosition, autoHarvestRange)
    local Bushes = {}

    for _, Part in next, Parts do
        if Part.Parent and table.find(allowedBushNames, Part.Parent.Name) then
            table.insert(Bushes, Part.Parent)
        end
    end

    local Closest, LastDist = nil, math.huge

    for _, Bush in next, Bushes do
        local Dist = (characterPosition - Bush:GetPivot().Position).Magnitude
        if Dist < LastDist then
            Closest = Bush
            LastDist = Dist
        end
    end

    return Closest
end

local function GetClosestBushes()
    local characterPosition = LocalPlayer.Character:GetPivot().Position
    local Parts = workspace:GetPartBoundsInRadius(characterPosition, 35)
    local Bushes = {}

    for _, Part in ipairs(Parts) do
        if Part.Parent and table.find(allowedBushNames, Part.Parent.Name) then
            table.insert(Bushes, Part.Parent)
        end
    end

    table.sort(Bushes, function(a, b)
        local distA = (characterPosition - a:GetPivot().Position).Magnitude
        local distB = (characterPosition - b:GetPivot().Position).Magnitude
        return distA < distB
    end)

    return Bushes
end

local function GetRandomBush()
    local characterPosition = LocalPlayer.Character:GetPivot().Position
    local Parts = workspace:GetPartBoundsInRadius(characterPosition, 150)
    local Bushes = {}

    task.wait()

    for _, Part in next, Parts do
        if Part.Parent and table.find(allowedBushNames, Part.Parent.Name) then
            table.insert(Bushes, Part.Parent)
        end
    end

    if #Bushes == 0 then
        return nil
    end

    local randomIndex = math.random(1, #Bushes)
    return Bushes[randomIndex]
end

local function canMoveToPosition(startPos, endPos)
    local rayDirection = (endPos - startPos).Unit * (endPos - startPos).Magnitude
    local raycastParams = RaycastParams.new()
    raycastParams.FilterDescendantsInstances = {LocalPlayer.Character}
    raycastParams.FilterType = Enum.RaycastFilterType.Blacklist

    local raycastResult = workspace:Raycast(startPos, rayDirection, raycastParams)
    return raycastResult == nil, raycastResult
end

local function facePlayerTo(position)
    local character = LocalPlayer.Character
    if not character then return end
    local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
    if not humanoidRootPart then return end

    local lookAt = CFrame.lookAt(humanoidRootPart.Position, position)
    humanoidRootPart.CFrame = lookAt
end

local function adjustCameraToPosition(position)
    local Camera = workspace.CurrentCamera
    Camera.CFrame = CFrame.lookAt(Camera.CFrame.Position, position)
end

local function swingTool(entityID)
    local bufferSize = 4 + 2
    local buf = buffer.create(bufferSize)
    local offset = 0

    buffer.writeu32(buf, offset, entityID)
    offset = offset + 4

    buffer.writeu16(buf, offset, 1)
    offset = offset + 2

    local finalBuffer = buffer.create(offset)
    buffer.copy(finalBuffer, 0, buf, 0, offset)
    Packets.SwingTool.send(finalBuffer)
end

local function getTargets(radius, targetName)
    local characterPosition = LocalPlayer.Character:GetPivot().Position
    local Parts = workspace:GetPartBoundsInRadius(characterPosition, radius)
    local targets = {}

    for _, Part in ipairs(Parts) do
        if Part.Parent and Part.Parent:IsA("Model") and Part.Parent.Name == targetName then
            table.insert(targets, Part.Parent)
        end
    end

    return targets
end

local function ggetTargets(radius)
    local characterPosition = LocalPlayer.Character:GetPivot().Position

    local Parts = {}
    local success, err = pcall(function()
        Parts = workspace:GetPartBoundsInRadius(characterPosition, radius)
    end)

    local targets = {}

    for _, Part in ipairs(Parts) do
        if Part.Parent and Part.Parent:IsA("Model") and (Part.Name == "Gold Node" or Part.Name == "Ice Chunk") then
            local health = Part:FindFirstChild("Health")
            if health and health.Value > 0 then
                table.insert(targets, Part.Parent)
            end
        end
    end

    return targets
end

local function GetNearestBush()
    local characterPosition = LocalPlayer.Character:GetPivot().Position
    local Parts = workspace:GetPartBoundsInRadius(characterPosition, 250)
    local Bushes = {}

    for _, Part in next, Parts do
        local parentName = Part.Parent and Part.Parent.Name
        if parentName and table.find(allowedBushNames, parentName) then
            table.insert(Bushes, Part.Parent)
        end
    end

    if #Bushes == 0 then
        return nil
    end

    local nearestBush = nil
    local shortestDistance = math.huge

    for _, Bush in ipairs(Bushes) do
        local distance = (characterPosition - Bush:GetPivot().Position).Magnitude
        if distance < shortestDistance then
            nearestBush = Bush
            shortestDistance = distance
        end
    end

    return nearestBush
end

local function HasSeed(Box)
    return Box:FindFirstChild("Seed") ~= nil
end

local function CanMove(pos)
    local last_cast = 0
    if (os.clock() - last_cast) < 0.2 then
        return false
    end
    last_cast = os.clock()
    local cast = workspace:Raycast(LocalPlayer.Character:GetPivot().Position, (pos - LocalPlayer.Character:GetPivot().Position), params)
    return cast == nil
end

local function GetRandomTeleportBox()
    local Deployables = workspace:FindFirstChild("Deployables")
    if not Deployables then 
        return nil 
    end

    local PlantBoxes = {}
    for _, part in ipairs(Deployables:GetChildren()) do
        if part.Name == "Plant Box" then
            table.insert(PlantBoxes, part)
        end
    end

    if #PlantBoxes == 0 then
        return nil
    end

    local startTime = tick()
    while tick() - startTime < 5 do
        task.wait(0.1)
        for _, selectedBox in ipairs(PlantBoxes) do
            local characterPosition = LocalPlayer.Character:GetPivot().Position
            local boxPosition = selectedBox:GetPivot().Position
            local distance = (characterPosition - boxPosition).Magnitude

            if not HasSeed(selectedBox) and distance > 35 and distance < 180 and CanMove(boxPosition + Vector3.new(0, 4, 0)) then
                return selectedBox
            end
        end
    end

    local randomIndex = math.random(1, #PlantBoxes)
    return PlantBoxes[randomIndex]
end

local findPlantBoxNext = true

local function FindTeleportTarget()
    if findPlantBoxNext then
        local plantBox = GetRandomTeleportBox()
        findPlantBoxNext = false
        return plantBox
    else
        local randomBush = GetRandomBush()
        findPlantBoxNext = true 
        return randomBush
    end
end


local function addHighlights()
    local totems = game.Workspace.Totems:GetChildren()
    for _, totem in ipairs(totems) do
        if totem.Name == "Tribe Totem" then
            local colorationPart = totem:FindFirstChild("Coloration")
            if colorationPart and colorationPart:IsA("BasePart") then
                local highlight = Instance.new("Highlight")
                highlight.FillColor = colorationPart.Color
                highlight.FillTransparency = 0.5
                highlight.OutlineColor = Color3.fromRGB(255, 255, 255)
                highlight.OutlineTransparency = 0
                highlight.Parent = totem
                highlights[totem] = highlight
            end
        end
    end
end

local function removeHighlights()
    for totem, highlight in pairs(highlights) do
        if highlight then
            highlight:Destroy()
        end
    end
    highlights = {}
end

local function parseFruitInput(input)
    SelectedFruits = {}
    for fruit in string.gmatch(input, "([^,]+)") do
        fruit = fruit:gsub("^%s*(.-)%s*$", "%1")
        table.insert(SelectedFruits, fruit)
    end
end

local function GetClosestCoin()
    local closestCoin
    local minDistance = 15
    local maxDistance = 35
    local RootPart = game.Players.LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
    local Items = game.Workspace:FindFirstChild("Items")

    if not RootPart or not Items then
        return nil
    end

    local PlayerPosition = RootPart.Position
    for _, item in pairs(Items:GetChildren()) do
        if (item:IsA("Model") or item:IsA("Part") or item:IsA("UnionOperation")) then

            if item.Name == "Coin2" then
            local ItemPosition = item:GetPivot().Position
            local Distance = (PlayerPosition - ItemPosition).Magnitude
            if Distance < maxDistance then
                minDistance = Distance
                closestCoin = item
            end
        end
        end
    end

    return closestCoin
end

local function getClosestResource(name)
    local characterPosition = Players.LocalPlayer.Character:GetPivot().Position
    local Parts = workspace:GetPartBoundsInRadius(characterPosition, 10)
    local resources = {}

    for _, Part in ipairs(Parts) do
        if Part.Parent and Part.Parent:IsA("Model") and Part.Parent.Name == name and Part.Parent:FindFirstChild("Health") then
            if Part.Parent.Health ~= 0 then
            table.insert(resources, Part.Parent)
            end
        end
    end

    return resources
end

local function getClosestDroppedItem()
    local closestItem
    local minDistance = 15
    local maxDistance = 35
    local RootPart = game.Players.LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
    local Items = game.Workspace:FindFirstChild("Items")

    if not RootPart or not Items then
        return nil
    end

    local PlayerPosition = RootPart.Position
    for _, item in pairs(Items:GetChildren()) do
        if (item:IsA("Model") or item:IsA("Part") or item:IsA("UnionOperation")) then

            local ItemPosition = item:GetPivot().Position
            local Distance = (PlayerPosition - ItemPosition).Magnitude
            if Distance < maxDistance then
                minDistance = Distance
                closestItem = item
            end
        end
    end

    return closestItem
end

local function getClosestDroppedGold()
    local closestItem
    local minDistance = 15
    local maxDistance = 35
    local RootPart = game.Players.LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
    local Items = game.Workspace:FindFirstChild("Items")

    if not RootPart or not Items then
        return nil
    end

    local PlayerPosition = RootPart.Position
    for _, item in pairs(Items:GetChildren()) do
        if (item:IsA("Model") or item:IsA("Part") or item:IsA("UnionOperation")) then

            if item.Name == "Raw Gold" then
            local ItemPosition = item:GetPivot().Position
            local Distance = (PlayerPosition - ItemPosition).Magnitude
            if Distance < maxDistance then
                minDistance = Distance
                closestItem = item
            end
        end
        end
    end

    return closestItem
end

local function getClosestItem(name)
    local closestItem
    local minDistance = 1
    local maxDistance = 35
    local RootPart = game.Players.LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
    local Items = game.Workspace:FindFirstChild("Items")

    if not RootPart or not Items then
        return nil
    end

    local PlayerPosition = RootPart.Position
    for _, item in pairs(Items:GetChildren()) do
        if (item:IsA("Model") or item:IsA("Part") or item:IsA("UnionOperation") or (item:IsA("MeshPart"))) then

            if item.Name == name then
            local ItemPosition = item:GetPivot().Position
            local Distance = (PlayerPosition - ItemPosition).Magnitude
            if Distance < maxDistance then
                minDistance = Distance
                closestItem = item
            end
        end
        end
    end

    return closestItem
end

local function autoPickupItems(itemType)
    local function getClosestItem(itemName)
        local closestItem = nil
        local minDistance = 15
        local maxDistance = 35
        local RootPart = game.Players.LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
        local Items = game.Workspace:FindFirstChild("Items")

        if not RootPart or not Items then
            return nil
        end

        local PlayerPosition = RootPart.Position
        for _, item in pairs(Items:GetChildren()) do
            if item.Name == itemName and (item:IsA("Model") or item:IsA("Part") or item:IsA("UnionOperation")) then
                local ItemPosition = item:GetPivot().Position
                local Distance = (PlayerPosition - ItemPosition).Magnitude
                if Distance < maxDistance and Distance < minDistance then
                    minDistance = Distance
                    closestItem = item
                end
            end
        end

        return closestItem
    end

    while true do
        if itemType == 1 then
            local item = getClosestItem("Gold")
            if item then
                PickUpItem(item)
            end
        elseif itemType == 2 then
            local item = getClosestItem("Crystal Chunk")
            if item then
                PickUpItem(item)
            end
        elseif itemType == 3 then
            local item1 = getClosestItem("Gold")
            if item1 then
                PickUpItem(item1)
            end
            local item2 = getClosestItem("Crystal Chunk")
            if item2 then
                PickUpItem(item2)
            end
        end
        task.wait(0.01)
    end
end

local TweenService = game:GetService("TweenService")
local LocalPlayer = Players.LocalPlayer
local character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
local HumanoidRootPart = character:WaitForChild("HumanoidRootPart")

local TweenService = game:GetService("TweenService")
local LocalPlayer = Players.LocalPlayer

local function getHumanoidRootPart()
    local character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
    return character:WaitForChild("HumanoidRootPart")
end

local function GetClosestPress()
    local characterPosition = LocalPlayer.Character:GetPivot().Position
    local Parts = workspace:GetPartBoundsInRadius(characterPosition, 35)
    local nearestPress = nil
    local shortestDistance = math.huge

    for _, Part in ipairs(Parts) do
        if Part.Parent and Part.Parent:IsA("Model") and Part.Parent.Name == "Coin Press" then
            local distance = (Part.Position - characterPosition).Magnitude
            if distance < shortestDistance then
                shortestDistance = distance
                nearestPress = Part.Parent
            end
        end
    end

    return nearestPress
end

local function dropGold(index)
    if index then
        Packets.DropBagItem.send(index)
    end
end

local function autoHit(targetName1, targetName2)
    local targets1 = getTargets(15, targetName1)
    local allTargets = {}

    for _, target in ipairs(targets1) do
        table.insert(allTargets, target)
    end

    if targetName2 then
        local targets2 = getTargets(15, targetName2)
        for _, target in ipairs(targets2) do
            table.insert(allTargets, target)
        end
    end

    for _, target in ipairs(allTargets) do
        if target and target:FindFirstChild("Health") and target.Health.Value > 0 then
            while target and target:FindFirstChild("Health") and target.Health.Value > 0 do
                swingTool(target:GetAttribute("EntityID"))
                task.wait(0.1)
            end
        end
    end
end

local function TogglenodeAura()
    while nodeAura and task.wait() do
        local iceChunks = getTargets(10, "Ice Chunk")
        local goldNodes = getTargets(10, "Gold Node")
        local allTargets = {}

        -- Combine ice chunks and gold nodes into one table
        for _, iceChunk in ipairs(iceChunks) do
            table.insert(allTargets, iceChunk)
        end
        for _, goldNode in ipairs(goldNodes) do
            table.insert(allTargets, goldNode)
        end

        -- Iterate over all targets and hit them
        for _, target in ipairs(allTargets) do
            if target and target:FindFirstChild("Health") then
                if target.Health.Value > 0 then
                    while target and target:FindFirstChild("Health") and target.Health.Value > 0 do
                        swingTool(target:GetAttribute("EntityID"))
                        task.wait(0.05)
                    end
                end
            end
        end
    end
end


local function getClosestCampfire()
    local characterPosition = LocalPlayer.Character:GetPivot().Position
    local Parts = workspace:GetPartBoundsInRadius(characterPosition, 50)
    local nearestCampfire = nil
    local shortestDistance = math.huge

    for _, Part in ipairs(Parts) do
        if Part.Parent and Part.Parent:IsA("Model") and Part.Parent.Name == "Campfire" then
            local distance = (Part.Position - characterPosition).Magnitude
            if distance < shortestDistance then
                shortestDistance = distance
                nearestCampfire = Part.Parent
            end
        end
    end

    if nearestCampfire then
        local textLabel = nearestCampfire:FindFirstChild("Board")
            and nearestCampfire.Board:FindFirstChild("Billboard")
            and nearestCampfire.Board.Billboard:FindFirstChild("Backdrop")
            and nearestCampfire.Board.Billboard.Backdrop:FindFirstChild("TextLabel")

        if textLabel then
            local textValue = tonumber(textLabel.Text)
            if textValue and (textValue < 240 or textValue > 250) then
                return nearestCampfire
            end
        else
            return nearestCampfire
        end
    end
    return nil
end

local function getClosestCampfires()
    local characterPosition = LocalPlayer.Character:GetPivot().Position
    local Parts = workspace:GetPartBoundsInRadius(characterPosition, 15)
    local campfires = {}

    for _, Part in ipairs(Parts) do
        if Part.Parent and Part.Parent:IsA("Model") and Part.Parent.Name == "Campfire" then
            local distance = (Part.Position - characterPosition).Magnitude
            table.insert(campfires, {campfire = Part.Parent, distance = distance})
        end
    end

    -- Sort campfires by distance
    table.sort(campfires, function(a, b)
        return a.distance < b.distance
    end)

    local closestCampfires = {}
    for i = 1, math.min(3, #campfires) do
        local campfire = campfires[i].campfire
        local textLabel = campfire:FindFirstChild("Board")
            and campfire.Board:FindFirstChild("Billboard")
            and campfire.Board.Billboard:FindFirstChild("Backdrop")
            and campfire.Board.Billboard.Backdrop:FindFirstChild("TextLabel")

        if textLabel then
            local textValue = tonumber(textLabel.Text)
            if textValue and (textValue < 240 or textValue > 250) then
                table.insert(closestCampfires, campfire)
            end
        else
            table.insert(closestCampfires, campfire)
        end

        if #closestCampfires >= 3 then
            break
        end
    end

    return closestCampfires
end

local function powerCampfires()
    local campfires = getClosestCampfires()

    for i, campfire in ipairs(campfires) do

        if autoCampfire_Enabled then
            task.wait(0.1)
            local value = getValue("Wood")

            if value == nil then value = 1 end

            if value >= 2 then
                if not campfires then
                    campfires = getClosestCampfires()
                end
            end
            local cid = campfire:GetAttribute("EntityID")

            if cid then

            Packets.InteractStructure.send({["entityID"] = cid, ["itemID"] = ItemIDS["Wood"]})
            end
        end
    end
end

--[[


$$$$$$\   $$$$$$\  $$\       $$$$$$$\        $$$$$$$$\  $$$$$$\  $$$$$$$\  $$\      $$\       $$$$$$$$\ $$\   $$\ $$\   $$\  $$$$$$\ $$$$$$$$\ $$$$$$\  $$$$$$\  $$\   $$\ 
$$  __$$\ $$  __$$\ $$ |      $$  __$$\       $$  _____|$$  __$$\ $$  __$$\ $$$\    $$$ |      $$  _____|$$ |  $$ |$$$\  $$ |$$  __$$\\__$$  __|\_$$  _|$$  __$$\ $$$\  $$ |
$$ /  \__|$$ /  $$ |$$ |      $$ |  $$ |      $$ |      $$ /  $$ |$$ |  $$ |$$$$\  $$$$ |      $$ |      $$ |  $$ |$$$$\ $$ |$$ /  \__|  $$ |     $$ |  $$ /  $$ |$$$$\ $$ |
$$ |$$$$\ $$ |  $$ |$$ |      $$ |  $$ |      $$$$$\    $$$$$$$$ |$$$$$$$  |$$\$$\$$ $$ |      $$$$$\    $$ |  $$ |$$ $$\$$ |$$ |        $$ |     $$ |  $$ |  $$ |$$ $$\$$ |
$$ |\_$$ |$$ |  $$ |$$ |      $$ |  $$ |      $$  __|   $$  __$$ |$$  __$$< $$ \$$$  $$ |      $$  __|   $$ |  $$ |$$ \$$$$ |$$ |        $$ |     $$ |  $$ |  $$ |$$ \$$$$ |
$$ |  $$ |$$ |  $$ |$$ |      $$ |  $$ |      $$ |      $$ |  $$ |$$ |  $$ |$$ |\$  /$$ |      $$ |      $$ |  $$ |$$ |\$$$ |$$ |  $$\   $$ |     $$ |  $$ |  $$ |$$ |\$$$ |
\$$$$$$  | $$$$$$  |$$$$$$$$\ $$$$$$$  |      $$ |      $$ |  $$ |$$ |  $$ |$$ | \_/ $$ |      $$ |      \$$$$$$  |$$ | \$$ |\$$$$$$  |  $$ |   $$$$$$\  $$$$$$  |$$ | \$$ |
\______/  \______/ \________|\_______/       \__|      \__|  \__|\__|  \__|\__|     \__|      \__|       \______/ \__|  \__| \______/   \__|   \______| \______/ \__|  \__|
                                                                                                                                            
                                                                                                                                                                            
]]
local TweenService = game:GetService("TweenService")

local player = game.Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local humanoidRootPart = character:WaitForChild("HumanoidRootPart")

local function GetClosestPress()
    local characterPosition = LocalPlayer.Character:GetPivot().Position
    local Parts = workspace:GetPartBoundsInRadius(characterPosition, 50)
    local nearestCampfire = nil
    local shortestDistance = math.huge

    for _, Part in ipairs(Parts) do
        if Part.Parent and Part.Parent:IsA("Model") and Part.Parent.Name == "Coin Press" then
            local distance = (Part.Position - characterPosition).Magnitude
            if distance < shortestDistance then
                shortestDistance = distance
                nearestCampfire = Part.Parent
            end
        end
    end

    return nearestCampfire
end

local function getBox()
    local characterPosition = LocalPlayer.Character:GetPivot().Position
    local Parts = workspace:GetPartBoundsInRadius(characterPosition, 35)
    local nearestCampfire = nil
    local shortestDistance = math.huge

    for _, Part in ipairs(Parts) do
        if Part.Parent and Part.Parent:IsA("Model") and Part.Parent.Name == "Plant Box" then
            local distance = (Part.Position - characterPosition).Magnitude
            local seed = Part.Parent:FindFirstChild("Seed")

            if not seed then
                if distance < shortestDistance then
                    shortestDistance = distance
                    nearestCampfire = Part.Parent
                end
            end
        end
    end

    return nearestCampfire
end

local function getTPBox()
    local characterPosition = LocalPlayer.Character:GetPivot().Position
    local Parts = workspace:GetPartBoundsInRadius(characterPosition, 500)
    local nearestCampfire = nil
    local shortestDistance = math.huge

    for _, Part in ipairs(Parts) do
        if Part.Parent and Part.Parent:IsA("Model") and Part.Parent.Name == "Plant Box" then
            local distance = (Part.Position - characterPosition).Magnitude
            local seed = Part.Parent:FindFirstChild("Seed")

            if not seed then
                if distance < shortestDistance then
                    shortestDistance = distance
                    nearestCampfire = Part.Parent
                end
            end
        end
    end

    return nearestCampfire
end

local function getClosestDeployable(name)
    local characterPosition = LocalPlayer.Character:GetPivot().Position
    local Parts = workspace.Deployables:GetPartBoundsInRadius(characterPosition, 50)
    local nearestCampfire = nil
    local shortestDistance = math.huge

    for _, Part in ipairs(Parts) do
        if Part.Parent and Part.Parent:IsA("Model") and Part.Parent.Name == name then
            local distance = (Part.Position - characterPosition).Magnitude
            if distance < shortestDistance then
                shortestDistance = distance
                nearestCampfire = Part.Parent
            end
        end
    end

    return nearestCampfire
end

--[[


$$$$$$$$\  $$$$$$\  $$$$$$$\  $$\      $$\ $$$$$$\ $$\   $$\  $$$$$$\  
$$  _____|$$  __$$\ $$  __$$\ $$$\    $$$ |\_$$  _|$$$\  $$ |$$  __$$\ 
$$ |      $$ /  $$ |$$ |  $$ |$$$$\  $$$$ |  $$ |  $$$$\ $$ |$$ /  \__|
$$$$$\    $$$$$$$$ |$$$$$$$  |$$\$$\$$ $$ |  $$ |  $$ $$\$$ |$$ |$$$$\ 
$$  __|   $$  __$$ |$$  __$$< $$ \$$$  $$ |  $$ |  $$ \$$$$ |$$ |\_$$ |
$$ |      $$ |  $$ |$$ |  $$ |$$ |\$  /$$ |  $$ |  $$ |\$$$ |$$ |  $$ |
$$ |      $$ |  $$ |$$ |  $$ |$$ | \_/ $$ |$$$$$$\ $$ | \$$ |\$$$$$$  |
\__|      \__|  \__|\__|  \__|\__|     \__|\______|\__|  \__| \______/ 
                                                                    
                                                                                                                        
--]]

local Section = Farming:AddSection({
    Name = "Fruit Farm"
})

local autoFarmFruit

Farming:AddDropdown({
    Name = "Fruit",
    Default = "",
    Options = allowedFruits,
    Callback = function(Value)
        autoFarmFruit = Value
    end    
})

local canPlant = false

Farming:AddToggle({
    Name = "Auto Farm",
    Default = false,
    Callback = function(State)
        AutoTeleport_Enabled = State

        while AutoTeleport_Enabled do
            local target = nil

            if onlyBushes then
                target = GetNearestBush()
            else
                target = getTPBox()

                if target == nil then
                    target = GetNearestBush()
                end
            end

            if target then
                local playerPivot = LocalPlayer.Character:GetPivot()
                local targetPivot = target:GetPivot()
                local distance = (playerPivot.Position - targetPivot.Position).Magnitude
                local speed = distance / FarmingTweenSpeed

                local TI = TweenInfo.new(speed, Enum.EasingStyle.Linear, Enum.EasingDirection.InOut)
                local Tween = game:GetService("TweenService"):Create(LocalPlayer.Character.PrimaryPart, TI, {CFrame = targetPivot * CFrame.new(0, 4.2, 0)})

                Tween:Play()
                Tween.Completed:Wait()
            else
                task.wait(1)
            end
        end
    end
})

local test = false

local Section = Farming:AddSection({
    Name = "Auto Farm Settings"
})

Farming:AddToggle({
    Name = "Only Go For Bushes",
    Default = false,
    Callback = function(State)
        onlyBushes = State
    end
})

Farming:AddToggle({
    Name = "Auto Plant",
    Default = false,
    Callback = function(State)
        AutoPlant_Enabled = State
        spawn(function()
            while AutoPlant_Enabled and task.wait() do
                local Box = GetClosestBox()
                if Box then
                    local e = Box:GetAttribute("EntityID")
                    local fruit = autoFarmFruit
                    if ItemIDS[autoFarmFruit] then
                        Packets.InteractStructure.send({["entityID"] = e, ["itemID"] = ItemIDS[autoFarmFruit]})
                    end
                end
            end
        end)
    end
})

Farming:AddToggle({
    Name = "Auto Harvest",
    Default = false,
    Save = true,
    Flag = "harvest",
    Callback = function(State)
        AutoHarvest_Enabled = State
        while AutoHarvest_Enabled do
            task.wait()
            local Bushes = GetClosestBushes()
            task.wait()
            for _, Bush in ipairs(Bushes) do
                if Bush then
                    PickUpItem(Bush)
                end
            end
        end
    end
})


Farming:AddSlider({
    Name = "Tween Speed",
    Min = 0,
    Max = 40,
    Default = 10,
    Color = Color3.fromRGB(255, 255, 255),
    Increment = 0.1,
    ValueName = "studs/sec",
    Callback = function(Value)
        FarmingTweenSpeed = Value
    end
})

local Section = Farming:AddSection({
    Name = "Gold Farm"
})

local function TweenToPosition(position)
    local character = Players.LocalPlayer.Character
    if not character then return end
    local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
    if not humanoidRootPart then return end

    local tweenInfo = TweenInfo.new((humanoidRootPart.Position - position).Magnitude / tptweenspeed, Enum.EasingStyle.Linear, Enum.EasingDirection.InOut)
    local tween = TweenService:Create(humanoidRootPart, tweenInfo, {CFrame = CFrame.new(position)})
    tween:Play()
    tween.Completed:Wait()
end

local function allResourcesDepleted(resources)
    for _, resource in ipairs(resources) do
        local health = resource:FindFirstChild("Health")
        if health and health.Value > 0 then
            return false
        end
    end
    return true
end

local function test()
    while true do
        task.wait()
        while test do
            for _, pos in ipairs(nodePos) do
                if not test then break end
                TweenToPosition(pos)
                task.wait()
                if not test then break end
                local iceChunks = getClosestResource("Ice Chunk")
                local goldNodes = getClosestResource("Gold Node")


                local allDepleted = false
                while not allDepleted do
                    if not test then break end
                    allDepleted = true
                    for _, resource in ipairs(iceChunks) do
                        if not test then break end
                        local cid = resource:GetAttribute("EntityID")
                        if not test then break end
                        local health = resource:FindFirstChild("Health")
                        if health and health.Value > 0 then
                            swingTool(cid)
                            allDepleted = false
                            break
                        end
                    end

                    for _, resource in ipairs(goldNodes) do
                        if not test then break end
                        local cid = resource:GetAttribute("EntityID")
                        local health = resource:FindFirstChild("Health")
                        
                        if health and health.Value > 0 then
                            swingTool(cid)
                            allDepleted = false
                            break
                        end
                    end

                    task.wait()
                    if not test then break end
                end

                local rawGoldValue = getValue("Raw Gold")

                for i = 1, rawGoldValue do
                    task.wait()
                    Packets.DropBagItem(GetIndex("Raw Gold"))
                end

                task.wait(10)

                
            end
        end
    end
end

local function goldFarm()
    while true do
        task.wait(0.01)
        while isGoldFarm do
            for _, pos in ipairs(chunkPos) do
                if not isGoldFarm then break end
                TweenToPosition(pos)
                task.wait(0.1)
                if not isGoldFarm then break end
                local iceChunks = getClosestResource("Ice Chunk")
                local goldNodes = getClosestResource("Gold Node")


                local allDepleted = false
                while not allDepleted do
                    if not isGoldFarm then break end
                    allDepleted = true
                    for _, resource in ipairs(iceChunks) do
                        if not isGoldFarm then break end
                        local cid = resource:GetAttribute("EntityID")
                        if not isGoldFarm then break end
                        local health = resource:FindFirstChild("Health")
                        if health and health.Value > 0 then
                            swingTool(cid)
                            allDepleted = false
                            break
                        end
                    end

                    for _, resource in ipairs(goldNodes) do
                        if not isGoldFarm then break end
                        local cid = resource:GetAttribute("EntityID")
                        local health = resource:FindFirstChild("Health")
                        
                        if health and health.Value > 0 then
                            swingTool(cid)
                            allDepleted = false
                            break
                        end
                    end

                    task.wait(0.1)
                    if not isGoldFarm then break end
                end
            end
            task.wait(210)
        end
    end
end

spawn(goldFarm)
spawn(test)

Farming:AddToggle({
    Name = "Gold Farm",
    Default = false,
    Save = true,
    Flag = "campfire",
    Callback = function(State)
        isGoldFarm = State
    end
})

Farming:AddToggle({
    Name = "Gold Farm Test",
    Default = false,
    Save = true,
    Flag = "campfire",
    Callback = function(State)
        test = State
    end
})

local Section = Farming:AddSection({
    Name = "Settings"
})

local function powerCampfires()
    while true do
        task.wait(1)
        while autoCampfire_Enabled do
            local character = LocalPlayer.Character
            if character then
                local characterPosition = character:GetPivot().Position
                local parts = workspace:GetPartBoundsInRadius(characterPosition, 20)

                local campfireIds = {}
                for _, part in ipairs(parts) do
                    if part.Parent and part.Parent:IsA("Model") and part.Parent.Name == "Campfire" then
                        local cid = part.Parent:GetAttribute("EntityID")
                        if cid and not campfireIds[cid] then
                            Packets.InteractStructure.send({["entityID"] = cid, ["itemID"] = ItemIDS["Wood"]})
                            campfireIds[cid] = true
                        end
                    end
                end
            end
            task.wait(20)
        end
    end
end

spawn(powerCampfires)

Farming:AddToggle({
    Name = "Auto Campfire (USES STICKS)",
    Default = false,
    Save = true,
    Flag = "campfire",
    Callback = function(State)
        autoCampfire_Enabled = State
    end
})

Farming:AddToggle({
    Name = "Transport Gold To Chest",
    Default = false,
    Save = true,
    Flag = "tpGold",
    Callback = function(State)
        transportGold = State
        
        spawn(function()
            while transportGold do
                local chest = getClosestChest()
                local item = getClosestItem("Raw Gold")

                if item and chest then
                    local entityID = item:GetAttribute("EntityID")
                    local chestpos = chest:GetPivot().Position + Vector3.new(0, 2, 0)

                    if entityID and item then
                        Packets.ForceInteract.send(entityID)
                        task.wait()
                        item.Position = chestpos
                        task.wait()
                        Packets.ForceInteract.send()
                    end
                end
                task.wait(0.1)
            end
        end)
    end
})

spawn(autoCampfire)

local function autoCoinPressLoop()
    while true do
        if autoCoinPress_Enabled then
            local v = getValue("Gold")
            if v and v > 1 then
                task.wait(0.01) 
                local press = GetClosestPress()
                if press then
                    task.wait(0.01) 
                    local pressid = press:GetAttribute("EntityID")
                    Packets.InteractStructure.send({["entityID"] = pressid, ["itemID"] = ItemIDS["Gold"]})
                end
            end
        end
        task.wait()
    end
end

spawn(autoCoinPressLoop)

Farming:AddToggle({
    Name = "Auto Coin Press",
    Default = false,
    Save = true,
    Flag = "coinPress",
    Callback = function(State)
        autoCoinPress_Enabled = State
    end
})
Farming:AddToggle({
    Name = "Auto Pickup Coins",
    Default = false,
    Callback = function(State)
        autopickupcoins = State
        
        spawn(function()
            while autopickupcoins do
                task.wait()
                local item = GetClosestCoin()
                if item then
                    PickUpItem(item)
                end
            end
        end)
    end
})

local function autoPickupItemsLoop()
    while true do
        if autoPickupItems_Enabled then
            local item = getClosestDroppedGold()
            if item then
                PickUpItem(item)
            end
        end
        task.wait() 
    end
end

Farming:AddToggle({
    Name = "Auto Pickup Gold (from chest)",
    Default = false,
    Save = true,
    Flag = "goldFromChest",
    Callback = function(State)
        autoGetChest = State
        spawn(function()
            while autoGetChest do
                task.wait()
                getClosestChest()
            end
        end)
    end
})

local picka = false

Farming:AddToggle({
    Name = "Pick Up Raw Gold",
    Default = false,
    Callback = function(State)
        picka = State
        if State then
            spawn(function()
                while picka do
                    task.wait(0.1)
                    local item = getClosestItem("Raw Gold")

                    if item then
                       PickUpItem(item)
                    end
                end
            end)
        end
    end
})

local aura = false

Farming:AddToggle({
    Name = "Node Aura",
    Default = false,
    Callback = function(State)
        picka = State
        nodeAura = State
spawn(TogglenodeAura)
    end
})

local function wasteLeavesLoop()
    while true do
        if autoleaves then
            local amt = getValue("Leaves")
            if amt == nil then amt = 1 end
            if amt >= wasteLeavesTo then
                Packets.CraftItem.send(164)
            end
        end
        task.wait(0.05)
    end
end

local wasteSticks = false

local function wasteSticks()
    while true do
        if wasteSticks then
            local amt = getValue("Wood")
            if amt == nil then amt = 1 end
            if amt >= 30 then
                Packets.CraftItem.send(248)
            end
        end
        task.wait(0.05)
    end
end

local wasetMag = false

local function wasetMag()
    while true do
        if wasetMag then
            local amt = getValue("Magnetite")
            if amt == nil then amt = 1 end
            if amt >= 10 then
                Packets.CraftItem.send(229)
            end
        end
        task.wait(0.05)
    end
end


local function wasteFruitLoop()
    while true do
        if wasteFruit then
            local amt = getValue(SelectedFruit)

            if amt == nil then amt = 1 end

            if amt >= wasteFruitTo then
                Packets.UseBagItem.send(GetIndex(SelectedFruit))
            end
        end
        task.wait(0.2) 
    end
end
local wasteMeat = false

local function wasteMeat()
    while true do
        if wasteMeat then
            local amt = getValue("Cooked Meat")

            if amt == nil then amt = 1 end

            if amt and amt ~= 1 then
                Packets.UseBagItem.send(GetIndex("Cooked Meat"))
            end
        end
        task.wait(0.2) 
    end
end
spawn(wasteMeat)
spawn(wasetMag)
spawn(wasteLeavesLoop)
spawn(wasteFruitLoop)
spawn(wasteSticks)

Farming:AddToggle({
    Name = "Waste Leaves",
    Default = false,
    Save = true,
    Flag = "wasteLeaves",
    Callback = function(State)
        autoleaves = State
    end
})
Farming:AddToggle({
    Name = "Waste Sticks",
    Default = false,
    Save = true,
    Flag = "wasteSticks",
    Callback = function(State)
        wasteSticks = State
    end
})

Farming:AddToggle({
    Name = "Waste Fruit",
    Default = false,
    Save = true,
    Flag = "wasteFruit",
    Callback = function(State)
        wasteFruit = State
    end
})
Farming:AddDropdown({
    Name = "Fruit",
    Default = "",
    Options = allowedFruits,
    Callback = function(Value)
        SelectedFruit = Value
    end    
})

Farming:AddSlider({
    Name = "Waste Leaves To: ",
    Min = 2,
    Max = 100,
    Default = 25,
    Color = Color3.fromRGB(255, 255, 255),
    Increment = 1,
    ValueName = "Leaves",
    Callback = function(Value)
        wasteLeavesTo = Value
    end
})

Farming:AddSlider({
    Name = "Waste Fruit To: ",
    Min = 1,
    Max = 100,
    Default = 25,
    Color = Color3.fromRGB(255, 255, 255),
    Increment = 1,
    ValueName = "Amount",
    Callback = function(Value)
        wasteFruitTo = Value
    end
})

local autohit_critters = false

local doubPos = {Vector3.new(136.22882080078125, 27.407007217407227, 1002.1758422851562), Vector3.new(155.91908264160156, 27.407007217407227, 1003.8519897460938), Vector3.new(183.5193328857422, 27.407007217407227, 1006.2020263671875), Vector3.new(209.15614318847656, 27.7423152923584, 1012.0953369140625), Vector3.new(216.98963928222656, 27.854345321655273, 1026.181884765625), Vector3.new(207.23439025878906, 27.9843692779541, 1038.82421875), Vector3.new(206.8644561767578, 27.9843692779541, 1047.850341796875), Vector3.new(214.8244171142578, 27.9843692779541, 1053.220703125), Vector3.new(214.8244171142578, 27.9843692779541, 1053.220703125), Vector3.new(214.8244171142578, 27.9843692779541, 1053.220703125), Vector3.new(214.8244171142578, 27.9843692779541, 1053.220703125), Vector3.new(215.22750854492188, 27.972251892089844, 1053.78369140625), Vector3.new(215.2540283203125, 27.983243942260742, 1053.8177490234375), Vector3.new(202.14552307128906, 27.9843692779541, 1052.2098388671875), Vector3.new(207.008056640625, 27.95280647277832, 1033.8116455078125), Vector3.new(221.52597045898438, 27.8791446685791, 1024.53369140625), Vector3.new(240.75721740722656, 27.922386169433594, 1032.3675537109375), Vector3.new(258.9746398925781, 27.9843692779541, 1039.8704833984375), Vector3.new(273.52789306640625, 27.987354278564453, 1037.7303466796875), Vector3.new(275.5472412109375, 27.99028778076172, 1042.4176025390625), Vector3.new(275.4360046386719, 27.990917205810547, 1042.20263671875), Vector3.new(275.4307861328125, 27.99100685119629, 1042.1920166015625), Vector3.new(275.4270324707031, 27.99104118347168, 1042.18408203125), Vector3.new(275.4196472167969, 27.989593505859375, 1042.168701171875), Vector3.new(275.40570068359375, 27.990489959716797, 1042.13623046875), Vector3.new(275.2518615722656, 27.989946365356445, 1041.877685546875), Vector3.new(275.2518615722656, 27.990713119506836, 1041.877685546875), Vector3.new(284.7881164550781, 27.9999942779541, 1035.4217529296875), Vector3.new(288.3099670410156, 27.9999942779541, 1032.6229248046875), Vector3.new(289.7247619628906, 27.9999942779541, 1019.8463134765625), Vector3.new(292.10443115234375, 27.905046463012695, 1014.32763671875), Vector3.new(292.06298828125, 27.998899459838867, 1014.3470458984375), Vector3.new(292.06298828125, 27.9999942779541, 1014.3470458984375), Vector3.new(292.06298828125, 27.9999942779541, 1014.3470458984375), Vector3.new(292.06298828125, 27.9999942779541, 1014.3470458984375), Vector3.new(292.06298828125, 27.9999942779541, 1014.3470458984375), Vector3.new(292.06298828125, 27.9999942779541, 1014.3470458984375), Vector3.new(290.69189453125, 27.906721115112305, 991.2308959960938), Vector3.new(290.69189453125, 27.90684700012207, 991.2308959960938), Vector3.new(290.69189453125, 27.90684700012207, 991.2308959960938), Vector3.new(290.69189453125, 27.90684700012207, 991.2308959960938), Vector3.new(290.69189453125, 27.90684700012207, 991.2308959960938), Vector3.new(290.69189453125, 27.90684700012207, 991.2308959960938), Vector3.new(292.3896179199219, 27.9999942779541, 1006.22119140625), Vector3.new(304.7315979003906, 27.9999942779541, 1003.2716674804688), Vector3.new(322.99871826171875, 27.94240379333496, 988.8087158203125), Vector3.new(330.51947021484375, 28.0937442779541, 980.7296142578125), Vector3.new(330.51947021484375, 28.0937442779541, 980.7296142578125), Vector3.new(330.51947021484375, 28.0937442779541, 980.7296142578125), Vector3.new(330.51947021484375, 28.0937442779541, 980.7296142578125), Vector3.new(330.51947021484375, 28.0937442779541, 980.7296142578125), Vector3.new(341.9828186035156, 28.0937442779541, 978.8539428710938), Vector3.new(335.3605651855469, 28.0937442779541, 979.2015380859375), Vector3.new(391.1689758300781, 29.5576171875, 1000.818115234375), Vector3.new(397.38232421875, 30.560346603393555, 1000.9340209960938), Vector3.new(401.47601318359375, 32.600250244140625, 1015.3229370117188), Vector3.new(418.7880859375, 33.3106689453125, 1030.1265869140625), Vector3.new(446.9067077636719, 33.6093635559082, 1046.6005859375), Vector3.new(446.9067077636719, 33.6093635559082, 1046.6005859375), Vector3.new(446.9067077636719, 33.6093635559082, 1046.6005859375), Vector3.new(446.9067077636719, 33.6093635559082, 1046.6005859375), Vector3.new(448.4717102050781, 33.6093635559082, 1047.517578125), Vector3.new(448.6320495605469, 33.6093635559082, 1047.6114501953125), Vector3.new(448.6320495605469, 33.6093635559082, 1047.6114501953125), Vector3.new(449.10821533203125, 33.60921096801758, 1047.862548828125), Vector3.new(449.2812194824219, 33.60931396484375, 1047.97412109375), Vector3.new(449.3507995605469, 33.608848571777344, 1048.01806640625), Vector3.new(449.36328125, 33.6093635559082, 1048.0257568359375), Vector3.new(449.9368591308594, 33.6093635559082, 1048.3353271484375), Vector3.new(432.9761657714844, 33.6093635559082, 1042.8095703125), Vector3.new(412.3917541503906, 33.20654296875, 1026.64453125), Vector3.new(394.4355163574219, 31.05380630493164, 1009.2281494140625), Vector3.new(368.0077209472656, 29.28954315185547, 999.1678466796875), Vector3.new(356.197509765625, 28.160064697265625, 986.8296508789062), Vector3.new(334.3296813964844, 28.0937442779541, 987.1204223632812), Vector3.new(312.15570068359375, 27.9999942779541, 999.884765625), Vector3.new(292.17236328125, 27.9999942779541, 1023.3300170898438), Vector3.new(272.150390625, 27.985511779785156, 1042.6060791015625), Vector3.new(255.283447265625, 27.983665466308594, 1041.0283203125), Vector3.new(240.9461669921875, 27.9843692779541, 1036.4091796875), Vector3.new(222.73829650878906, 27.853431701660156, 1016.4689331054688), Vector3.new(197.2130584716797, 25.776531219482422, 1009.937744140625), Vector3.new(189.15260314941406, 27.407007217407227, 999.3128662109375), Vector3.new(185.93995666503906, 22.171998977661133, 991.4249877929688), Vector3.new(178.7185821533203, 21.391366958618164, 968.3261108398438), Vector3.new(173.03460693359375, 21.49840545654297, 942.9866333007812), Vector3.new(173.20538330078125, 20.026927947998047, 914.5475463867188), Vector3.new(173.6336669921875, 15.679272651672363, 843.2472534179688), Vector3.new(173.76626586914062, 16.971498489379883, 821.1716918945312), Vector3.new(174.1265106201172, 16.973403930664062, 761.1702880859375), Vector3.new(174.26995849609375, 18.362091064453125, 737.686767578125), Vector3.new(170.15234375, 20.847585678100586, 707.5299682617188), Vector3.new(168.14695739746094, 26.276107788085938, 672.8887329101562), Vector3.new(175.1843719482422, 26.665693283081055, 645.4976196289062), Vector3.new(179.0811767578125, 26.6406192779541, 626.879150390625), Vector3.new(184.4208526611328, 28.99734115600586, 587.55712890625), Vector3.new(208.6094970703125, 27.50612449645996, 559.8110961914062), Vector3.new(208.3052978515625, 26.70589828491211, 560.4566040039062), Vector3.new(208.3052978515625, 26.70589828491211, 560.4566040039062), Vector3.new(208.29556274414062, 26.705690383911133, 560.4716796875), Vector3.new(224.11524963378906, 26.808746337890625, 575.314453125), Vector3.new(250.67735290527344, 27.60016441345215, 589.6528930664062), Vector3.new(279.2519226074219, 27.307010650634766, 602.3184204101562), Vector3.new(290.6614685058594, 27.307010650634766, 607.3757934570312), Vector3.new(291.60235595703125, 27.307010650634766, 618.585205078125), Vector3.new(291.60235595703125, 27.307010650634766, 618.585205078125), Vector3.new(291.60235595703125, 27.307010650634766, 618.585205078125), Vector3.new(299.9998779296875, 27.307010650634766, 629.3478393554688), Vector3.new(313.89154052734375, 20.764049530029297, 629.7593994140625), Vector3.new(358.129638671875, 20.957279205322266, 626.1989135742188), Vector3.new(374.6348876953125, 27.338138580322266, 619.1427001953125), Vector3.new(374.6348876953125, 27.338138580322266, 619.1427001953125), Vector3.new(374.6348876953125, 27.338138580322266, 619.1427001953125), Vector3.new(374.6348876953125, 27.338138580322266, 619.1427001953125), Vector3.new(367.4608459472656, 26.707012176513672, 597.8060302734375), Vector3.new(359.7288818359375, 26.707012176513672, 577.1552734375), Vector3.new(361.87689208984375, 26.707012176513672, 566.6453247070312), Vector3.new(365.4499816894531, 26.707012176513672, 528.74365234375), Vector3.new(365.4499816894531, 26.707012176513672, 528.74365234375), Vector3.new(373.7452392578125, 27.3749942779541, 571.8809814453125), Vector3.new(373.7452392578125, 27.3749942779541, 571.8809814453125), Vector3.new(373.7452392578125, 27.3749942779541, 571.8809814453125), Vector3.new(373.7452392578125, 27.3749942779541, 571.8809814453125), Vector3.new(362.7443542480469, 26.707012176513672, 546.0162963867188), Vector3.new(368.74188232421875, 27.29113006591797, 528.2139282226562), Vector3.new(368.74188232421875, 27.29113006591797, 528.2139282226562), Vector3.new(355.50689697265625, 26.707012176513672, 528.247802734375), Vector3.new(328.8255615234375, 16.954605102539062, 518.5394287109375), Vector3.new(299.81414794921875, 17.89460563659668, 504.9621887207031), Vector3.new(289.7596740722656, 26.707012176513672, 499.56329345703125), Vector3.new(289.7596740722656, 26.707012176513672, 499.56329345703125), Vector3.new(289.7596740722656, 26.707012176513672, 499.56329345703125), Vector3.new(289.7596740722656, 26.707012176513672, 499.56329345703125), Vector3.new(289.7596740722656, 26.707012176513672, 499.56329345703125), Vector3.new(279.583984375, 26.707012176513672, 517.5913696289062), Vector3.new(267.55499267578125, 26.70701026916504, 519.1016845703125), Vector3.new(247.37892150878906, 26.70701026916504, 515.589599609375), Vector3.new(245.50326538085938, 26.70701026916504, 507.9150085449219), Vector3.new(245.50326538085938, 26.70701026916504, 507.9150085449219), Vector3.new(245.50326538085938, 26.70701026916504, 507.9150085449219), Vector3.new(245.50326538085938, 26.70701026916504, 507.9150085449219), Vector3.new(242.98495483398438, 26.70701026916504, 508.56005859375), Vector3.new(238.58558654785156, 26.70701026916504, 517.2825317382812), Vector3.new(222.29751586914062, 26.70701026916504, 519.2664184570312), Vector3.new(201.6753692626953, 28.617795944213867, 522.8992919921875), Vector3.new(181.58682250976562, 28.9999942779541, 508.8702392578125), Vector3.new(159.06370544433594, 26.97943878173828, 479.1916809082031), Vector3.new(137.5466766357422, 27.3281192779541, 457.4504089355469), Vector3.new(119.76854705810547, 27.3281192779541, 422.4386901855469), Vector3.new(114.44361877441406, 31.01656150817871, 383.8502502441406), Vector3.new(108.85953521728516, 37.467742919921875, 357.2700500488281), Vector3.new(97.59016418457031, 40.10446548461914, 338.0596008300781), Vector3.new(97.57186889648438, 40.1068115234375, 338.0636901855469), Vector3.new(97.57186889648438, 40.1068115234375, 338.0636901855469), Vector3.new(82.22198486328125, 40.1406135559082, 330.1289367675781), Vector3.new(63.31233215332031, 40.13166046142578, 330.66851806640625), Vector3.new(55.766910552978516, 40.14533996582031, 340.9693298339844), Vector3.new(47.17763137817383, 40.1562385559082, 353.4867858886719), Vector3.new(47.17763137817383, 40.1562385559082, 353.4867858886719), Vector3.new(47.17763137817383, 40.1562385559082, 353.4867858886719), Vector3.new(47.17763137817383, 40.1562385559082, 353.4867858886719), Vector3.new(60.2381477355957, 40.12928771972656, 342.8684387207031), Vector3.new(67.71868133544922, 40.1406135559082, 328.5882263183594), Vector3.new(60.616458892822266, 40.12375259399414, 315.97601318359375), Vector3.new(42.305843353271484, 40.1093635559082, 306.107666015625), Vector3.new(42.305843353271484, 40.1093635559082, 306.107666015625), Vector3.new(42.305843353271484, 40.1093635559082, 306.107666015625), Vector3.new(42.305843353271484, 40.1093635559082, 306.107666015625), Vector3.new(42.305843353271484, 40.1093635559082, 306.107666015625), Vector3.new(42.305843353271484, 40.1093635559082, 306.107666015625), Vector3.new(42.305843353271484, 40.1093635559082, 306.107666015625), Vector3.new(48.549659729003906, 40.109901428222656, 298.7838439941406), Vector3.new(43.02180099487305, 40.50276184082031, 283.6703186035156), Vector3.new(43.453826904296875, 39.8906135559082, 263.6324462890625), Vector3.new(53.71598815917969, 39.916263580322266, 242.70419311523438), Vector3.new(53.71598815917969, 39.91630172729492, 242.70419311523438), Vector3.new(53.71598815917969, 39.91630172729492, 242.70419311523438), Vector3.new(53.71598815917969, 39.91630172729492, 242.70419311523438), Vector3.new(53.71598815917969, 39.91630172729492, 242.70419311523438), Vector3.new(74.10307312011719, 39.9374885559082, 230.40838623046875), Vector3.new(89.46558380126953, 39.9374885559082, 221.14675903320312), Vector3.new(89.46558380126953, 39.9374885559082, 221.14675903320312), Vector3.new(89.46558380126953, 39.9374885559082, 221.14675903320312), Vector3.new(89.46558380126953, 39.9374885559082, 221.14675903320312), Vector3.new(89.46558380126953, 39.9374885559082, 221.14675903320312), Vector3.new(89.46558380126953, 39.9374885559082, 221.14675903320312), Vector3.new(77.19921112060547, 39.9374885559082, 219.04087829589844), Vector3.new(66.5851821899414, 39.9374885559082, 202.38134765625), Vector3.new(66.5851821899414, 39.9374885559082, 202.38134765625), Vector3.new(66.5851821899414, 39.9374885559082, 202.38134765625), Vector3.new(66.5851821899414, 39.9374885559082, 202.38134765625), Vector3.new(66.5851821899414, 39.9374885559082, 202.38134765625), Vector3.new(66.5851821899414, 39.9374885559082, 202.38134765625), Vector3.new(66.5851821899414, 39.9374885559082, 202.38134765625), Vector3.new(66.5851821899414, 39.9374885559082, 202.38134765625), Vector3.new(66.5851821899414, 39.9374885559082, 202.38134765625), Vector3.new(66.5851821899414, 39.9374885559082, 202.38134765625), Vector3.new(66.5851821899414, 39.9374885559082, 202.38134765625), Vector3.new(66.5851821899414, 39.9374885559082, 202.38134765625), Vector3.new(66.5851821899414, 39.9374885559082, 202.38134765625), Vector3.new(70.06163787841797, 39.9374885559082, 217.60911560058594), Vector3.new(66.86922454833984, 39.9374885559082, 240.41012573242188), Vector3.new(53.4088249206543, 39.97997283935547, 257.71917724609375), Vector3.new(42.132591247558594, 40.48127746582031, 275.96710205078125), Vector3.new(54.03559112548828, 40.11884307861328, 300.7049865722656), Vector3.new(71.6853256225586, 40.1479606628418, 308.2287902832031), Vector3.new(62.03717803955078, 40.11701965332031, 343.42327880859375), Vector3.new(47.49225997924805, 40.1562385559082, 354.9780578613281), Vector3.new(63.56264877319336, 40.10179901123047, 339.4078674316406), Vector3.new(80.12904357910156, 40.1406135559082, 328.61846923828125), Vector3.new(95.71996307373047, 40.16472625732422, 341.4853515625), Vector3.new(110.51976013183594, 37.05388259887695, 359.5395202636719), Vector3.new(119.65880584716797, 30.595928192138672, 380.923583984375), Vector3.new(117.23017120361328, 27.51641845703125, 405.9547119140625), Vector3.new(118.55235290527344, 27.329116821289062, 411.4300231933594), Vector3.new(119.34932708740234, 27.3281192779541, 430.557373046875), Vector3.new(123.92951202392578, 26.55550765991211, 517.6937866210938), Vector3.new(128.3431854248047, 26.628406524658203, 583.7332153320312), Vector3.new(134.265625, 26.6406192779541, 672.329833984375), Vector3.new(136.58883666992188, 21.528093338012695, 707.08203125), Vector3.new(137.84840393066406, 20.824583053588867, 725.9210815429688), Vector3.new(142.4016876220703, 17.7042179107666, 794.0227661132812), Vector3.new(145.16970825195312, 16.316383361816406, 835.4212646484375), Vector3.new(149.56423950195312, 16.51754379272461, 901.26611328125), Vector3.new(152.7167205810547, 21.06962013244629, 948.3688354492188), Vector3.new(152.17880249023438, 21.039506912231445, 976.283935546875), Vector3.new(151.9432830810547, 21.3737850189209, 982.9176635742188)}

Farming:AddToggle({
    Name = "Hit Pirates",
    Default = false,
    Save = true,
    Flag = "servants",
    Callback = function(State)
        autohit_critters = State
        if State then
            spawn(function()
                while autohit_critters do
                    task.wait(0.1)
                    local character = LocalPlayer.Character
                    if character then
                        local characterPosition = character:GetPivot().Position
                        local parts = workspace:GetPartBoundsInRadius(characterPosition, 20)
    
                        local entityIDs = {}
                        for _, part in ipairs(parts) do
                            if part.Parent and part.Parent.Name == "Crewmate" or part.Parent and part.Parent.Name == "Captain" then
                                local cid = part.Parent:GetAttribute("EntityID")
                                local health = part.Parent:FindFirstChild("Health")
    
                                if cid and health and health.Value > 0 then
                                    table.insert(entityIDs, cid)
                                end
                            end
                        end
    
                        if #entityIDs > 0 then
                            Packets.SwingTool.send(entityIDs)
                        end
                    end
                end
            end)
        end
    end
})


Farming:AddToggle({
    Name = "Auto Farm Pirates",
    Default = false,
    Save = true,
    Flag = "s",
    Callback = function(State)
        doubloons = State
        if State then
            spawn(function()
                while doubloons do
                    task.wait()
                    local character = LocalPlayer.Character
                    if character then
                        local characterPosition = character:GetPivot().Position
                        local parts = workspace:GetPartBoundsInRadius(characterPosition, 20)
                        if not doubloons then break end
    
                        for i, pos in ipairs(doubPos) do
                            TweenToPosition(pos)
                            task.wait(0.5)
                            if not doubloons then break end
                        end
                    end
                end
            end)
        end
    end
})

Farming:AddButton({
    Name = "Make Waypoint",
    Callback = function()
        local position = Vector3.new(136.22882080078125, 27.407007217407227, 1002.1758422851562)

        local cylinder = Instance.new("Part")
        cylinder.Name = "waypoint"
        cylinder.Material = "Neon"
        cylinder.Size = Vector3.new(5, 1000, 5) -- Adjusted width and depth
        cylinder.Position = position
        cylinder.Orientation = Vector3.new(0,90,0)
        cylinder.Anchored = true
        cylinder.BrickColor = BrickColor.new("Bright red")
        cylinder.CanCollide = false

        local highlight = Instance.new("Highlight")
        highlight.Parent = cylinder

        cylinder.Parent = game.Workspace
    end
})

Farming:AddButton({
    Name = "Delete Waypoint",
    Callback = function()
        for i, v in ipairs(workspace:GetChildren()) do
            if v.Name == "waypoint" then
                v.Transparency = 1
            end
        end
    end
})

--[[

    
$$\      $$\ $$$$$$\  $$$$$$\   $$$$$$\  $$$$$$$$\ $$\       $$\        $$$$$$\  $$\   $$\ $$$$$$$$\  $$$$$$\  $$\   $$\  $$$$$$\  
$$$\    $$$ |\_$$  _|$$  __$$\ $$  __$$\ $$  _____|$$ |      $$ |      $$  __$$\ $$$\  $$ |$$  _____|$$  __$$\ $$ |  $$ |$$  __$$\ 
$$$$\  $$$$ |  $$ |  $$ /  \__|$$ /  \__|$$ |      $$ |      $$ |      $$ /  $$ |$$$$\ $$ |$$ |      $$ /  $$ |$$ |  $$ |$$ /  \__|
$$\$$\$$ $$ |  $$ |  \$$$$$$\  $$ |      $$$$$\    $$ |      $$ |      $$$$$$$$ |$$ $$\$$ |$$$$$\    $$ |  $$ |$$ |  $$ |\$$$$$$\  
$$ \$$$  $$ |  $$ |   \____$$\ $$ |      $$  __|   $$ |      $$ |      $$  __$$ |$$ \$$$$ |$$  __|   $$ |  $$ |$$ |  $$ | \____$$\ 
$$ |\$  /$$ |  $$ |  $$\   $$ |$$ |  $$\ $$ |      $$ |      $$ |      $$ |  $$ |$$ |\$$$ |$$ |      $$ |  $$ |$$ |  $$ |$$\   $$ |
$$ | \_/ $$ |$$$$$$\ \$$$$$$  |\$$$$$$  |$$$$$$$$\ $$$$$$$$\ $$$$$$$$\ $$ |  $$ |$$ | \$$ |$$$$$$$$\  $$$$$$  |\$$$$$$  |\$$$$$$  |
\__|     \__|\______| \______/  \______/ \________|\________|\________|\__|  \__|\__|  \__|\________| \______/  \______/  \______/ 
                                                                                                                                
                                                                                                                                
                                    
--]]


local Section12 = Misc:AddSection({
    Name = "UI Settings"
})

local function toggleLowDetailMode()
    local ldm = true

    if ldm then
        game.Lighting.FogEnd = 1000

        game.Lighting.GlobalShadows = false

        for _, part in ipairs(workspace:GetDescendants()) do
            if part:IsA("BasePart") then
                part.Material = Enum.Material.Plastic
                if part:FindFirstChildOfClass("Decal") then
                    part:FindFirstChildOfClass("Decal"):Destroy()
                end
            end
        end
    end
end

Misc:AddButton({
    Name = "Unload UI",
    Callback = function()
        AutoPlant_Enabled = false
        AutoTeleport_Enabled = false
        AutoHarvest_Enabled = false

        OrionLib:Destroy()
    end
})

local Section13 = Misc:AddSection({
    Name = "Webhook Settings"
})

Misc:AddToggle({
    Name = "Webhook Sending",
    Default = false,
    Callback = function(Value)
        webhookSending = Value

        if Value then
            startWebhookSending()
        end
    end
})

Misc:AddTextbox({
    Name = "Webhook URL",
    Default = "",
    TextDisappear = false,
    Callback = function(Value)
        webhookUrl1 = Value
    end
})

Misc:AddDropdown({
    Name = "Fruit",
    Default = "",
    Options = allowedFruits,
    Callback = function(Value)
        fruitToSend = Value
        lastFruitValue = 0
        startFruitValue = 0
    end    
})

Misc:AddSlider({
    Name = "Interval",
    Min = 1,
    Max = 60,
    Default = 10,
    Color = Color3.fromRGB(255,255,255),
    Increment = 1,
    ValueName = "minutes",
    Callback = function(Value)
        webhookInterval = Value
        webhookInSeconds = (webhookInterval * 60)
    end    
})

Misc:AddButton({
    Name = "Test Webhook",
    Callback = function()
        testWebhook()
    end    
})

local Section13 = Misc:AddSection({
    Name = "Preformance"
})

Misc:AddButton({
    Name = "Destroy Items",
    Callback = function()
        local itemsFolder = game.Workspace:FindFirstChild("Items")
        if itemsFolder then
            for i, v in ipairs(itemsFolder:GetChildren()) do
                if v:IsA("BasePart") then
                    v.Transparency = 1
                    v.CanCollide = false
                elseif v:IsA("Model") then
                    for _, part in ipairs(v:GetDescendants()) do
                        if part:IsA("BasePart") then
                            part.Transparency = 1
                            part.CanCollide = false
                        end
                    end
                end
            end
        else
            warn("Items folder not found in Workspace")
        end
    end
})

Misc:AddButton({
    Name = "Low Detail Mode",
    Callback = function()
        toggleLowDetailMode()
    end
})

--[[


$$$$$$$$\ $$$$$$$$\ $$\       $$$$$$$$\ $$$$$$$\   $$$$$$\  $$$$$$$\ $$$$$$$$\  $$$$$$\  
\__$$  __|$$  _____|$$ |      $$  _____|$$  __$$\ $$  __$$\ $$  __$$\\__$$  __|$$  __$$\ 
$$ |   $$ |      $$ |      $$ |      $$ |  $$ |$$ /  $$ |$$ |  $$ |  $$ |   $$ /  \__|
$$ |   $$$$$\    $$ |      $$$$$\    $$$$$$$  |$$ |  $$ |$$$$$$$  |  $$ |   \$$$$$$\  
$$ |   $$  __|   $$ |      $$  __|   $$  ____/ $$ |  $$ |$$  __$$<   $$ |    \____$$\ 
$$ |   $$ |      $$ |      $$ |      $$ |      $$ |  $$ |$$ |  $$ |  $$ |   $$\   $$ |
$$ |   $$$$$$$$\ $$$$$$$$\ $$$$$$$$\ $$ |       $$$$$$  |$$ |  $$ |  $$ |   \$$$$$$  |
\__|   \________|\________|\________|\__|       \______/ \__|  \__|  \__|    \______/ 
                                                                                        
                                                                                                                                                                    
--]]



local function TeleportLoop()
    while tpenabled do
        for _, position in ipairs(tps) do
            if tpenabled then
                TweenToPosition(position)
            else
                break
            end
            task.wait(tpinverval)
        end
        task.wait()
    end
end

local HttpService = game:GetService("HttpService")
local TeleportService = game:GetService("TeleportService")
local LocalPlayer = game.Players.LocalPlayer

local function getServers(id)
    local response = request({
        Url = string.format("https://games.roblox.com/v1/games/%s/servers/0?sortOrder=2&excludeFullGames=true&limit=100", id)
    })
    return HttpService:JSONDecode(response.Body)
end

local Section = Teleports:AddSection({
    Name = "Server Teleports"
})

local function teleportToServer(placeId, serverId)
    if serverId then
        TeleportService:TeleportToPlaceInstance(placeId, serverId, LocalPlayer)
    else
        warn("No valid server found for teleportation.")
    end
end

Teleports:AddButton({
    Name = "Big Void Server (More Players)",
    Callback = function()
        local servers = getServers(11879754496).data
        local touse = {}
        for _, v in pairs(servers) do
            if v.playing > 25 then
                table.insert(touse, v.id)
            end
        end
        local bestid = #touse > 0 and touse[math.random(1, #touse)] or servers[1] and servers[1].id
        teleportToServer(11879754496, bestid)
    end    
})

Teleports:AddButton({
    Name = "Small Void Server (Less Players)",
    Callback = function()
        local servers = getServers(11879754496).data
        local touse = {}
        for _, v in pairs(servers) do
            if v.playing < 10 then
                table.insert(touse, v.id)
            end
        end
        local bestid = #touse > 0 and touse[math.random(1, #touse)] or servers[1] and servers[1].id
        teleportToServer(11879754496, bestid)
    end    
})

Teleports:AddButton({
    Name = "Low Latency Void",
    Callback = function()
        local servers = getServers(11879754496).data
        local bestid
        local bestval = 200
        for _, v in pairs(servers) do
            if v.ping < bestval then
                bestval = v.ping
                bestid = v.id
            end
        end
        teleportToServer(11879754496, bestid)
    end    
})

Teleports:AddButton({
    Name = "Small Overworld Server (Less Players)",
    Callback = function()
        local servers = getServers(11729688377).data
        local touse = {}
        for _, v in pairs(servers) do
            if v.playing < 10 then
                table.insert(touse, v.id)
            end
        end
        local bestid = #touse > 0 and touse[math.random(1, #touse)] or servers[1] and servers[1].id
        teleportToServer(11729688377, bestid)
    end    
})

Teleports:AddButton({
    Name = "Big Overworld Server (More Players)",
    Callback = function()
        local servers = getServers(11729688377).data
        local touse = {}
        for _, v in pairs(servers) do
            if v.playing > 25 then
                table.insert(touse, v.id)
            end
        end
        local bestid = #touse > 0 and touse[math.random(1, #touse)] or servers[1] and servers[1].id
        teleportToServer(11729688377, bestid)
    end    
})

Teleports:AddButton({
    Name = "Low Latency Overworld",
    Callback = function()
        local servers = getServers(11729688377).data
        local bestid
        local bestval = 150
        for _, v in pairs(servers) do
            if v.ping < bestval then
                bestval = v.ping
                bestid = v.id
            end
        end
        teleportToServer(11729688377, bestid)
    end    
})

Teleports:AddButton({
    Name = "Random Overworld",
    Callback = function()
        local servers = getServers(11729688377).data
        local bestid = servers[math.random(1, #servers)].id
        while bestid == game.JobId do
            bestid = servers[math.random(1, #servers)].id
        end
        teleportToServer(11729688377, bestid)
    end    
})


local Section = Teleports:AddSection({
    Name = "Teleport Positions"
})


local sphereParts = {}

local function createSphereAtPosition(position)
    local sphere = Instance.new("Part")
    sphere.Transparency = 0.5
    sphere.Shape = Enum.PartType.Ball
    sphere.Color = Color3.new(1, 0, 0) -- Red color
    sphere.Material = Enum.Material.Neon
    sphere.Size = Vector3.new(1.5, 1.5, 1.5)
    sphere.Anchored = true
    sphere.CanCollide = false
    sphere.Position = position.Position + Vector3.new(0, -0.5, 0)
    sphere.Parent = game.Workspace
    table.insert(sphereParts, sphere)
end

local function removeSphere()
    for c, sphere in ipairs(sphereParts) do
        task.wait()
        sphere.Transparency = 1
    end
end

Teleports:AddButton({
    Name = "Set Position",
    Callback = function()
        local playerPos = Players.LocalPlayer.Character.HumanoidRootPart.Position
        table.insert(tps, playerPos)
        createSphereAtPosition(playerPos)
        OrionLib:MakeNotification({
            Name = "Set position " .. #tps .. " to player's position",
            Content = "Completed",
            Image = "rbxassetid://4483345998",
            Time = 2
        })
    end    
})

Teleports:AddButton({
    Name = "Clear Positions",
    Callback = function()
        OrionLib:MakeNotification({
            Name = "Successfully cleared all " .. #tps .. " positions.",
            Content = "Completed",
            Image = "rbxassetid://4483345998",
            Time = 2
        })

        removeSphere()
        
        tps = {}
    end    
})

Teleports:AddSlider({
    Name = "Tween Speed",
    Min = 1,
    Max = 40,
    Default = 19,
    Color = Color3.fromRGB(255, 255, 255),
    Increment = 0.5,
    ValueName = "studs/sec",
    Callback = function(Value)
        tptweenspeed = Value
    end    
})

Teleports:AddSlider({
    Name = "Tween Interval",
    Min = 0,
    Max = 60,
    Default = 10,
    Color = Color3.fromRGB(255, 255, 255),
    Increment = 0.5,
    ValueName = "secs",
    Callback = function(Value)
        tpinverval = Value
    end    
})

Teleports:AddToggle({
    Name = "Teleport Tweening",
    Default = false,
    Callback = function(Value)
        tpenabled = Value
        if tpenabled then
            spawn(TeleportLoop)
        end
    end    
})

--[[


$$$$$$$\  $$\        $$$$$$\ $$\     $$\ $$$$$$$$\ $$$$$$$\  
$$  __$$\ $$ |      $$  __$$\\$$\   $$  |$$  _____|$$  __$$\ 
$$ |  $$ |$$ |      $$ /  $$ |\$$\ $$  / $$ |      $$ |  $$ |
$$$$$$$  |$$ |      $$$$$$$$ | \$$$$  /  $$$$$\    $$$$$$$  |
$$  ____/ $$ |      $$  __$$ |  \$$  /   $$  __|   $$  __$$< 
$$ |      $$ |      $$ |  $$ |   $$ |    $$ |      $$ |  $$ |
$$ |      $$$$$$$$\ $$ |  $$ |   $$ |    $$$$$$$$\ $$ |  $$ |
\__|      \________|\__|  \__|   \__|    \________|\__|  \__|
                                                            
                                                                                                                        
--]]

local function GetIndex(fruit)
    for i, v in pairs(GameUtil.Data.inventory) do
        if v.name == fruit then
            return i
        end
    end
end

local function startAutoHeal()
    spawn(function()
        while autoheal_enabled do
            local player = game.Players.LocalPlayer
            local health = player.Character and player.Character:FindFirstChild("Humanoid") and player.Character.Humanoid.Health

            if health and health <= autohealAt then
                local fruitIndex = GetIndex(autohealFruit)
                if fruitIndex then
                    Packets.UseBagItem.send(fruitIndex)
                    task.wait(1 / autoHealCPS)
                end
            end

            task.wait()
        end
    end)
end

local Section = Player:AddSection({
    Name = "Player Settings"
})

Player:AddToggle({
    Name = "Auto Heal",
    Default = false,
    Callback = function(Value)
        autoheal_enabled = Value
        if Value then
            startAutoHeal()
        end
    end    
})

local Section = Player:AddSection({
    Name = "Auto Heal Settings"
})

Player:AddDropdown({
    Name = "Fruit",
    Default = "",
    Options = allowedFruits,
    Callback = function(Value)
        autohealFruit = Value
    end    
})

Player:AddSlider({
    Name = "Auto Heal To: ",
    Min = 1,
    Max = 100,
    Default = 100,
    Color = Color3.fromRGB(255,255,255),
    Increment = 1,
    ValueName = "Health",
    Callback = function(Value)
        autohealTo = Value
    end    
})

Player:AddSlider({
    Name = "Auto Heal At: ",
    Min = 1,
    Max = 100,
    Default = 98,
    Color = Color3.fromRGB(255,255,255),
    Increment = 1,
    ValueName = "Health",
    Callback = function(Value)
        autohealAt = Value
    end    
})

Player:AddSlider({
    Name = "CPS",
    Min = 1,
    Max = 100,
    Default = 50,
    Color = Color3.fromRGB(255,255,255),
    Increment = 1,
    ValueName = "CPS",
    Callback = function(Value)
        autoHealCPS = Value
    end    
})

--[[Player:AddToggle({
    Name = "Auto Pick Up",
    Default = false,
    Callback = function(Value)
        autoPickup = Value
        spawn(function()
            while autoPickup do
                task.wait()
                local item = getClosestDroppedItem()

                PickUpItem(item)
            end
        end)
    end    
})--]]

local Section = Player:AddSection({
    Name = "Player Settings"
})

Player:AddToggle({
    Name = "Mountain Climber",
    Default = false,
    Callback = function(State)
        if State then
            character = getPlayerCharacter()
            character:WaitForChild("Humanoid").MaxSlopeAngle = 89
        else
            character = getPlayerCharacter()
            character:WaitForChild("Humanoid").MaxSlopeAngle = 46
        end
    end
})

local mt = getrawmetatable(game.Players.LocalPlayer)
setreadonly(mt, false)

local oldIndex = mt.__index
local oldNewIndex = mt.__newindex

mt.__index = function(t, k)
    if k == "WalkSpeed" and wwenabled then
        return wwspeed
    end

    return oldIndex(t, k)
end

mt.__newindex = function(t, k, v)
    if k == "WalkSpeed" and wwenabled then
        v = wwspeed
    end
    oldNewIndex(t, k, v)
end

setreadonly(mt, true)

Player:AddToggle({
    Name = "Water Walker",
    Default = false,
    Callback = function(State)
        wwenabled = State
    end
})

Player:AddSlider({
    Name = "Water Walker Speed",
    Min = 1,
    Max = 50,
    Default = 16,
    Color = Color3.fromRGB(255, 255, 255),
    Increment = 1,
    ValueName = "WalkSpeed",
    Callback = function(Value)
        wwspeed = Value
    end
})

local Section = Player:AddSection({
    Name = "Auto Pick Up"
})

Player:AddToggle({
    Name = "Auto Pick Up Godsets",
    Default = false,
    Callback = function(State)
        autoPickupGodSets = State
        if State then
            spawn(function()
                while autoPickupGodSets do
                    task.wait(0.01)
                    autoPickupItems(3)
                end
            end)
        end
    end
})

Player:AddToggle({
    Name = "Auto Pick Up Gold",
    Default = false,
    Callback = function(State)
        autoPickupGold = State
        if State then
            spawn(function()
                while autoPickupGold do
                    task.wait(0.01)
                    autoPickupItems(1)
                end
            end)
        end
    end
})

Player:AddToggle({
    Name = "Auto Pick Up Crystal",
    Default = false,
    Callback = function(State)
        autoPickupCrystal = State
        if State then
            spawn(function()
                while autoPickupCrystal do
                    task.wait(0.01)
                    autoPickupItems(2)
                end
            end)
        end
    end
})
